# SimpleKernel 多核与任务管理

## IA32

TODO

## RISCV

任务上下文
```c++
namespace CPU {

/**
 * @brief 上下文，用于任务切换
 * @note caller_regs 由编译器保存/恢复
 */
struct context_t {
    /// 运行此任务的 core id
    uintptr_t            coreid;
    uintptr_t            ra;
    CPU::callee_regs_t   callee_regs;
    CPU::satp_t          satp;
    uintptr_t            sepc;
    CPU::sstatus_t       sstatus;
    uintptr_t            sie;
    uintptr_t            sip;
    uintptr_t            sscratch;
};

}; // namespace CPU
```

任务切换
```assembly
/**
 * @brief 保存 context_t
 * @param  _base           要保存到的基地址
 */
.macro context_save _base
    // @todo 临时设置为 tp
    sd_base          tp,       0,                    \_base
    sd_base          ra,       1,                    \_base
    callee_regs_save \_base,   2

    csrr             t6,       satp
    sd_base          t6,       2 + CALLEE_SAVE_REGS, \_base

    csrr             t6,       sepc
    sd_base          t6,       3 + CALLEE_SAVE_REGS, \_base

    csrr             t6,       sstatus
    sd_base          t6,       4 + CALLEE_SAVE_REGS, \_base

    csrr             t6,       sie
    sd_base          t6,       5 + CALLEE_SAVE_REGS, \_base

    csrr             t6,       sip
    sd_base          t6,       6 + CALLEE_SAVE_REGS, \_base

    csrr             t6,       sscratch
    sd_base          t6,       7 + CALLEE_SAVE_REGS, \_base
.endm

/**
 * @brief 恢复 context_t
 * @param  _base           要恢复数据的基地址
 */
.macro context_load _base
    // @todo 临时设置为 tp
    ld_base          tp,       0,                    \_base
    ld_base          ra,       1,                    \_base
    callee_regs_load \_base,   2

    ld_base          t6,       2 + CALLEE_SAVE_REGS, \_base
    csrw             satp,     t6

    ld_base          t6,       3 + CALLEE_SAVE_REGS, \_base
    csrw             sepc,     t6

    ld_base          t6,       4 + CALLEE_SAVE_REGS, \_base
    csrw             sstatus,  t6

    ld_base          t6,       5 + CALLEE_SAVE_REGS, \_base
    csrw             sie,      t6

    ld_base          t6,       6 + CALLEE_SAVE_REGS, \_base
    csrw             sip,      t6

    ld_base          t6,       7 + CALLEE_SAVE_REGS, \_base
    csrw             sscratch, t6
.endm

/**
 * @brief 上下文切换
 * @param  _old             当前进程
 * @param  _new             下一个进程
 */
// void switch_context(context_t *_old, context_t *_new);
.globl switch_context
.align 4
switch_context:
    // 保存 _old
    context_save a0
    // 恢复 _new
    context_load a1
    sfence.vma
    // 跳转到 _new->ra 执行
    ret
```

调度器，抽象出 `SCHEDULER`，目前使用了 rr 调度器

```c++
class rr_scheduler_t : scheduler_t {
private:
    /// 任务向量
    mystl::queue<task_t *> task_queue;

protected:
public:
    rr_scheduler_t(void);
    rr_scheduler_t(const mystl::string _name);
    ~rr_scheduler_t(void);

    /**
     * @brief 添加一个任务
     * @param  _task            要添加的任务
     */
    void add_task(task_t *_task) override;

    /**
     * @brief 删除任务
     * @param  _task            要删除的任务
     */
    void remove_task(task_t *_task) override;

    /**
     * @brief 获取下一个要运行的任务
     * @return task_t*          下一个要运行的任务
     */
    task_t *get_next_task(void) override;
};
```

自旋锁
```c++
/**
 * @brief 自旋锁
 * @note 只能用于多核
 */
struct spinlock_t {
private:
    /// 自旋锁名称
    const char *name;
    /// 是否 lock
    std::atomic_flag locked;
    /// 获得此锁的 hartid
    size_t hartid;

    /**
     * @brief 检查当前 hart 是否获得此锁
     * @return true             是
     * @return false            否
     */
    bool is_holding(void);

    /**
     * @brief 中断嵌套+1
     */
    void push_off(void);

    /**
     * @brief 中断嵌套-1
     */
    void pop_off(void);

public:
    spinlock_t(void);

    /**
     * @brief 构造函数
     * @param  _name            锁名
     * @note 需要堆初始化后可用
     */
    spinlock_t(const char *_name);

    /**
     * @brief 构造函数
     * @param  _name            锁名
     * @note 需要 libcxx 始化后可用
     */
    spinlock_t(const mystl::string &_name);

    /**
     * @brief 初始化，用于堆完成之前的初始化
     * @param  _name            锁名称
     * @return true             成功
     * @return false            失败
     */
    bool init(const char *_name);

    /**
     * @brief 获得锁
     */
    void lock(void);

    /**
     * @brief 释放锁
     */
    void unlock(void);
};
```


更多细节请查看注释。

- 相关代码

    ./src/include/scheduler/*

    src/include/task.h

    ./src/arch/riscv64/task/*

    ./src/include/smp_task.h

    ./src/kernel/smp_task.cpp

    ./src/include/spinlock.h

    ./src/kernel/spinlock.cpp


## 相关文档

TODO
